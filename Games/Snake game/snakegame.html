<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>OurAni</title>
  <link rel="stylesheet" type="text/css" href="snakegame.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <div class="loader"></div>
  <header>
    <a href="../../INDEX.html" class="logo">Our-ani</a>
    <ul>
      <li><a href="../../INDEX.html" class="active">Home</a></li>
      <li><a class="GoBack" href="../../gamespage.html"><i class="fa fa-angle-left" aria-hidden="true"></i></a></li>
    </ul>
  </header>

  <div class="container">
    <div class="game-board-container">
      <p id="game-over">Game Over</p>
    </div>
    <span class="line"></span>
    <div class="btn-container">
      <button class="btn">Left</button>
      <button class="btn">Up</button>
      <button class="btn">Right</button>
      <button class="btn">Down</button>
    </div>
  </div>

  <p id="score">Score: 0</p>

  <!-- Inline JavaScript -->
  <script>
    const gameBoardContainer = document.querySelector('.game-board-container');
    const DPI = window.devicePixelRatio;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    function createCanvas(width, height) {
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      canvas.width = Math.floor(width * DPI);
      canvas.height = Math.floor(height * DPI);
      ctx.scale(DPI, DPI);
      gameBoardContainer.appendChild(canvas);
    }

    function background(color = 'black') {
      canvas.style.background = color;
    }

    const Direction = {
      RIGHT: 1,
      LEFT: 2,
      UP: 3,
      DOWN: 4,
    };

    class SnakeGameAI {
      constructor(w = 360, h = 400) {
        this.w = w;
        this.h = h;
        this.blockSize = 10;
        this.reset();
      }

      reset() {
        this.pos = { x: 5, y: 8 };
        this.snakeArr = [
          { x: 5, y: 8 },
          { x: 4, y: 8 },
          { x: 3, y: 8 },
        ]; // Snake starts with 3 blocks
        this.score = 0;
        this.frameRate = 10;
        this.colors = ["#FF0000", "#00FF00", "#0000FF", "#FF00FF", "#FFFF00", "#00FFFF"];
        this.direction = Direction.RIGHT; // Default direction
        this.#placeFood();
      }

      playStep(key) {
        if (
          (key === Direction.LEFT && this.direction === Direction.RIGHT) ||
          (key === Direction.RIGHT && this.direction === Direction.LEFT) ||
          (key === Direction.UP && this.direction === Direction.DOWN) ||
          (key === Direction.DOWN && this.direction === Direction.UP)
        ) {
          key = this.direction; // Ignore invalid reverse moves
        }
        this.direction = key;

        const head = { ...this.snakeArr[0] };
        if (key === Direction.LEFT) head.x -= 1;
        else if (key === Direction.UP) head.y -= 1;
        else if (key === Direction.RIGHT) head.x += 1;
        else if (key === Direction.DOWN) head.y += 1;

        // Check collision with food
        if (head.x === this.foodPos.x && head.y === this.foodPos.y) {
          this.snakeArr.unshift(head); // Add new head
          this.#placeFood(); // Place new food
          this.score++;
          if (this.score % 5 === 0) {
            this.frameRate += 2; // Increase speed every 5 points
          }
        } else {
          this.snakeArr.pop(); // Remove tail
          this.snakeArr.unshift(head); // Add new head
        }

        if (this.#gameOver()) {
          return { gameOver: true, score: this.score };
        }

        return { gameOver: false, score: this.score };
      }

      draw(ctx) {
        ctx.clearRect(0, 0, this.w, this.h);

        // Draw snake
        this.snakeArr.forEach((segment, i) => {
          ctx.fillStyle = this.colors[i % this.colors.length];
          ctx.fillRect(
            segment.x * this.blockSize,
            segment.y * this.blockSize,
            this.blockSize,
            this.blockSize
          );
        });

        // Draw food
        ctx.fillStyle = 'blue';
        ctx.fillRect(
          this.foodPos.x * this.blockSize,
          this.foodPos.y * this.blockSize,
          this.blockSize,
          this.blockSize
        );
      }

      #placeFood() {
        let validPosition = false;
        while (!validPosition) {
          this.foodPos = {
            x: Math.floor(Math.random() * (this.w / this.blockSize)),
            y: Math.floor(Math.random() * (this.h / this.blockSize)),
          };
          validPosition = !this.snakeArr.some(
            segment => segment.x === this.foodPos.x && segment.y === this.foodPos.y
          );
        }
      }

      #gameOver() {
        const head = this.snakeArr[0];
        // Check wall collisions
        if (head.x < 0 || head.x >= this.w / this.blockSize || head.y < 0 || head.y >= this.h / this.blockSize) {
          return true;
        }

        // Check self-collision
        return this.snakeArr.slice(1).some(segment => segment.x === head.x && segment.y === head.y);
      }

      getFrameRate() {
        return this.frameRate;
      }
    }

    createCanvas(360, 400);
    background('#D5D5D5');

    const buttons = document.querySelectorAll('.btn');
    const btnLeft = buttons[0];
    const btnUp = buttons[1];
    const btnRight = buttons[2];
    const btnDown = buttons[3];
    const scoreDom = document.querySelector('#score');
    const gameOverDom = document.querySelector('#game-over');
    const snake = new SnakeGameAI();

    let CONTROL = Direction.RIGHT;
    btnLeft.addEventListener('click', () => CONTROL = Direction.LEFT);
    btnUp.addEventListener('click', () => CONTROL = Direction.UP);
    btnRight.addEventListener('click', () => CONTROL = Direction.RIGHT);
    btnDown.addEventListener('click', () => CONTROL = Direction.DOWN);

    let now, then = Date.now();
    let interval = 1000 / snake.getFrameRate();

    function animate() {
      now = Date.now();
      const delta = now - then;

      if (delta > interval) {
        then = now - (delta % interval);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const infoObj = snake.playStep(CONTROL);
        snake.draw(ctx);

        scoreDom.innerHTML = `Score: ${infoObj.score}`;
        interval = 1000 / snake.getFrameRate();

        if (infoObj.gameOver) {
          gameOverDom.style.visibility = 'visible';
          setTimeout(() => {
            snake.reset();
            gameOverDom.style.visibility = 'hidden';
          }, 2000);
        }
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
