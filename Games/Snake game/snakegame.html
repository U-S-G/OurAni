<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>OurAni</title>
  <link rel="stylesheet" type="text/css" href="snakegame.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <div class="loader"></div>
  <header>
    <a href="../../INDEX.html" class="logo">Our-ani</a>
    <ul>
        <li><a href="../../INDEX.html" class="active">Home</a></li>
        <li><a class="GoBack" href="../../gamespage.html"><i class="fa fa-angle-left" aria-hidden="true"></i></a></li>
    </ul>
  </header>

  <div class="container">
    <div class="game-board-container">
      <p id="game-over">Game Over</p>
    </div>
    <span class="line"></span>
    <div class="btn-container">
      <button class="btn">Left</button>
      <button class="btn">Up</button>
      <button class="btn">Right</button>
      <button class="btn">Down</button>
    </div>
  </div>

  <p id="score">Score:0</p>

  <!-- Link the external JavaScript file -->
  <script src="snakegame.js">
    class SnakeGameAI {
    constructor(w = 360, h = 400) {
        this.w = w;
        this.h = h;
        this.blockSize = 10;
        this.reset();
    }

    reset() {
        this.pos = { x: 5, y: 8 }; // Snake's starting position
        this.snakeArr = [this.pos, this.pos, this.pos];
        this.score = 0;
        this.frameRate = 10;
        this.colors = ["#FF0000", "#00FF00", "#0000FF", "#FF00FF", "#FFFF00", "#00FFFF"];
        this.#placeFood(); // Ensure food is placed when the game resets
    }

    playStep(key) {
        // Move the snake
        for (let i = this.snakeArr.length - 1; i > 0; i--) {
            this.snakeArr[i] = { ...this.snakeArr[i - 1] };
        }
        this.#move(key);

        // Check for collision with food
        if (this.pos.x === this.foodPos.x && this.pos.y === this.foodPos.y) {
            this.#placeFood(); // Generate new food position
            this.snakeArr.push(this.pos); // Grow the snake
            this.score++;
            if (this.score % 5 === 0) {
                this.frameRate += 2; // Increase speed every 5 points
            }
        }

        // Check for game over
        if (this.#gameover()) {
            this.reset();
            return { gameOver: true, score: this.score };
        }

        return { gameOver: false, score: this.score };
    }

    draw(ctx) {
        ctx.clearRect(0, 0, this.w, this.h); // Clear the canvas

        // Draw the snake
        for (let i = 0; i < this.snakeArr.length; i++) {
            ctx.fillStyle = this.colors[i % this.colors.length];
            ctx.fillRect(
                this.snakeArr[i].x * this.blockSize,
                this.snakeArr[i].y * this.blockSize,
                this.blockSize,
                this.blockSize
            );
        }

        // Draw the food
        ctx.fillStyle = 'blue';
        ctx.fillRect(
            this.foodPos.x * this.blockSize,
            this.foodPos.y * this.blockSize,
            this.blockSize,
            this.blockSize
        );
    }

    #placeFood() {
        let validPosition = false;
        while (!validPosition) {
            this.foodPos = {
                x: Math.floor(Math.random() * (this.w / this.blockSize)),
                y: Math.floor(Math.random() * (this.h / this.blockSize)),
            };

            // Check if the food overlaps with the snake
            validPosition = !this.snakeArr.some(
                segment => segment.x === this.foodPos.x && segment.y === this.foodPos.y
            );
        }
    }

    #move(key) {
        if (key === Direction.LEFT) this.pos.x -= 1;
        else if (key === Direction.UP) this.pos.y -= 1;
        else if (key === Direction.RIGHT) this.pos.x += 1;
        else if (key === Direction.DOWN) this.pos.y += 1;
    }

    #gameover() {
        const headPos = { ...this.snakeArr[0] };
        // Check for collision with walls
        if (headPos.x < 0 || headPos.x >= this.w / this.blockSize ||
            headPos.y < 0 || headPos.y >= this.h / this.blockSize) {
            return true;
        }

        // Check for collision with itself
        for (let i = 1; i < this.snakeArr.length; i++) {
            if (headPos.x === this.snakeArr[i].x && headPos.y === this.snakeArr[i].y) {
                return true;
            }
        }
        return false;
    }

    getFrameRate() {
        return this.frameRate;
    }
}

  </script>
</body>
</html>
